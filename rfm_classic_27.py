# -*- coding: utf-8 -*-
"""
Классическая RFM-сегментация (27 сегментов) на основе датасета OnlineRetail.csv
Результаты сохраняются в RFM_Clusters_27.csv с описанием и рекомендациями по работе.
"""

import pandas as pd
import numpy as np
from datetime import datetime

# 1. Загрузка и предварительная обработка данных (как в оригинальном скрипте)
print("1. Загрузка данных...")
df = pd.read_csv('/Users/egorkrivchenko/PycharmProjects/scikit-learn/OnlineRetail.csv', encoding='ISO-8859-1')

# Удаляем строки с пропущенными CustomerID
df = df.dropna(subset=['CustomerID'])

# Удаляем отмененные заказы и некорректные количества
df = df[~df['InvoiceNo'].astype(str).str.startswith('C')]
df = df[df['Quantity'] > 0]
df = df[df['UnitPrice'] >= 0]

# Преобразуем CustomerID в целое число
df['CustomerID'] = df['CustomerID'].astype(int)

# Преобразуем дату
df['InvoiceDate'] = pd.to_datetime(df['InvoiceDate'], format='%d-%m-%Y %H:%M')

print(f"Данные загружены. Количество строк после очистки: {len(df)}")

# 2. Создание RFM-метрик (как в оригинальном скрипте)
print("2. Создание RFM-метрик...")

# Определяем "сегодняшнюю" дату
snapshot_date = df['InvoiceDate'].max() + pd.Timedelta(days=1)

# Рассчитываем общую сумму
df['TotalSum'] = df['Quantity'] * df['UnitPrice']

# Группируем по CustomerID
rfm_table = df.groupby('CustomerID').agg({
    'InvoiceDate': lambda x: (snapshot_date - x.max()).days, # Recency
    'InvoiceNo': 'nunique',                                  # Frequency
    'TotalSum': 'sum'                                        # Monetary
}).reset_index()

# Переименовываем колонки
rfm_table.columns = ['CustomerID', 'Recency', 'Frequency', 'Monetary']

# Удаляем клиентов с Monetary = 0
rfm_table = rfm_table[rfm_table['Monetary'] > 0]

print(f"RFM-таблица создана. Количество клиентов: {len(rfm_table)}")

# 3. Классическая RFM-сегментация (3 балла по каждой метрике)
print("3. Выполнение классической RFM-сегментации...")

# Находим квантили для определения пороговых значений
# Для Recency: чем МЕНЬШЕ значение, тем лучше (1 - лучший)
recency_quantiles = rfm_table['Recency'].quantile([0.33, 0.66]).values
# Для Frequency и Monetary: чем БОЛЬШЕ значение, тем лучше (1 - лучший)
frequency_quantiles = rfm_table['Frequency'].quantile([0.33, 0.66]).values
monetary_quantiles = rfm_table['Monetary'].quantile([0.33, 0.66]).values

# Функция для присвоения RFM-рейтинга
def get_rfm_score(value, quantiles, is_recency=False):
    if is_recency:
        # Для Recency: низкое значение = высокий балл
        if value <= quantiles[0]:
            return 1
        elif value <= quantiles[1]:
            return 2
        else:
            return 3
    else:
        # Для Frequency и Monetary: высокое значение = высокий балл
        if value > quantiles[1]:
            return 1
        elif value > quantiles[0]:
            return 2
        else:
            return 3

# Присваиваем рейтинги
rfm_table['R_score'] = rfm_table['Recency'].apply(lambda x: get_rfm_score(x, recency_quantiles, is_recency=True))
rfm_table['F_score'] = rfm_table['Frequency'].apply(lambda x: get_rfm_score(x, frequency_quantiles))
rfm_table['M_score'] = rfm_table['Monetary'].apply(lambda x: get_rfm_score(x, monetary_quantiles))

# Создаем общий RFM-сегмент в виде строки
rfm_table['Сегмент'] = rfm_table['R_score'].astype(str) + rfm_table['F_score'].astype(str) + rfm_table['M_score'].astype(str)

# 4. Добавление описаний и механик общения
print("4. Добавление описаний и рекомендаций по работе...")

# Словарь с описаниями клиентов
описание_клиента = {
    '111': 'Покупали недавно, покупают часто, большой чек',
    '112': 'Покупали недавно, покупают часто, средний чек',
    '113': 'Покупали недавно, покупают часто, низкий чек',
    '121': 'Покупали недавно, покупают редко, большой чек',
    '122': 'Покупали недавно, покупают редко, средний чек',
    '123': 'Покупали недавно, покупают редко, низкий чек',
    '131': 'Покупали недавно, купили разово, большой чек',
    '132': 'Покупали недавно, купили разово, средний чек',
    '133': 'Покупали недавно, купили разово, низкий чек',
    '211': 'Спящие, покупают часто, высокий чек',
    '212': 'Спящие, покупают часто, средний чек',
    '213': 'Спящие, покупают часто, низкий чек',
    '221': 'Спящие, покупают редко, высокий чек',
    '222': 'Спящие, покупают редко, средний чек',
    '223': 'Спящие, покупают редко, низкий чек',
    '231': 'Спящие, купили разово, высокий чек',
    '232': 'Спящие, купили разово, средний чек',
    '233': 'Спящие, купили разово, низкий чек',
    '311': 'Уходящие, покупают часто, высокий чек',
    '312': 'Уходящие, покупают часто, средний чек',
    '313': 'Уходящие, покупают часто, низкий чек',
    '321': 'Уходящие, покупают редко, высокий чек',
    '322': 'Уходящие, покупают редко, средний чек',
    '323': 'Уходящие, покупают редко, низкий чек',
    '331': 'Уходящие, купили разово, высокий чек',
    '332': 'Уходящие, купили разово, средний чек',
    '333': 'Уходящие, купили разово, низкий чек'
}

# Словарь с механиками общения
механики_общения = {
    '111': 'Уделять особое внимание. Предлагать нематериальные бонусы и эксклюзивный доступ',
    '112': 'Не перегружать сообщениями. Отправлять персональные подборки и акции, чтобы поддерживать интерес',
    '113': 'Стимулировать рост среднего чека за счет акций — например, купи на сумму N и получи подарок или скидку',
    '121': 'Постоянных клиентов, которые недавно совершили покупку, стоит регулярно спрашивать о товаре, чтобы вовремя понять, что что-то пошло не так',
    '122': 'Предлагать более дорогие товары, протестировать увеличение частоты рассылок',
    '123': 'Поддерживать интерес клиентов к товарам: сообщать про новинки, отправлять предложения с сопутствующими товарами или аксессуарами к тем товарам, которые они уже купили',
    '131': 'Удержать персональными рассылками с полезными материалами, эксклюзивный доступ к новым продуктам и персонализированную поддержку',
    '132': 'Рассказать больше о продукте, заинтересовать функционалом',
    '133': 'Вернуть к диалог уперсональным касанием, снизить количество рассылок',
    '211': 'Понять причину ухода.',
    '212': 'Напомнить о себе, предложить уникальный промокод.',
    '213': 'Вернуть к диалогу персональным сообщением',
    '221': 'Напомнить о ценности продукта, предложить акции',
    '222': 'Активировать через персонализированное предложение',
    '223': 'Понять причину малой активности, предложить релевантные продукты',
    '231': 'Напомнить о ценности продукта, предложить акции',
    '232': 'Активировать через персонализированное предложение',
    '233': 'Понять причину малой активности, предложить релевантные продукты',
    '311': 'Понять причину уменьшения покупок, предложить скидку.',
    '312': 'Активировать через персонализированное предложение',
    '313': 'Активировать через персонализированное предложение',
    '321': 'Выяснить причину ухода, предложить индивидуальные условия',
    '322': 'Исследовать потребности, предложить подходящие товары или услуги',
    '323': 'Повысить интерес к продукту через образовательный контент',
    '331': 'Эти клиенты, скорее всего, не вернутся. Предложить персонализированные условия для повторной покупки',
    '332': 'Эти клиенты, скорее всего, не вернутся. На всякий случай им можно отправить реактивационную рассылку с промокодом. Если они не реагируют на сообщения больше года, их можно удалить из базы',
    '333': 'Низкозатратные активации: предложение скидки или акционного товара, основанного на прошлой покупке'
}

# Применяем словари к таблице
rfm_table['Описание клиента'] = rfm_table['Сегмент'].map(описание_клиента)
rfm_table['Механики общения'] = rfm_table['Сегмент'].map(механики_общения)

# 5. Сохранение результатов
output_path = '/Users/egorkrivchenko/PycharmProjects/scikit-learn/RFM_Clusters_27.csv'
rfm_table.to_csv(output_path, index=False)
print(f"\nРезультаты классической RFM-сегментации сохранены в файл: {output_path}")

# 6. Краткая сводка по сегментам
segment_summary = rfm_table['Сегмент'].value_counts().sort_index()
print("\nКоличество клиентов в каждом сегменте:")
print(segment_summary)